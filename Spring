Spring: framework for building Java applications

Spring core framework:



Java Application Server: Tomcat


Inversion of Control(IoC):


configuring Spring COntainer:
	XML file;
	Java Annotations
	Java Source Code


example: 

	1. Configure your Spring Bean: applicationContext.xml
	<beans ... >
		<bean id="myCoach"
			class="com.luv2code.springdemo.BaseballCoach">
		</bean>
	</beans>

	2. Create a Spring Container;
	ClassPathXmlApplicationContext context = new 
		ClassPathXmlApplicationContext("applicationContext.xml");

	3. Retrieve Beans from Container
	Coach theCoach = context.getBean("myCoach", Coach.class);

	When we pass the interface to the method, behind the scenes Spring will cast the object for you.throwing a BeanNotOfRequiredTypeException if the bean is not of the required type.



Spring Bean is a Java object

Create dependency:

Constructor injection:

	1. Define the dependency interface and class;

	2. Create a constructor in your class for injections

	3. Configure the dependency file in Spring config file

	in XML file:
	<bean id="myFortuneService"
		class="com.luv2code.springdeml.HappyFortuneService">
	</bean>

	<bean id="myCoach"
		class="com.luv2code.springdemo.BaseballCoach">
		<constructor-arg ref="myFortuneService" />
	</bean>

	done by Spring:

	HappyFortuneService myFortuneService = 
		new HappyFortuneService();

	BaseballCoach myCoach = 
		new BaseballCoach(myFortuneService);


Setter injection:

	1. Create setter methods in your class for injections

	2. Configure the dependency injection in Spring config file

	<property name="fortuneService" ref="myFortuneService" />
	setter method has format limit


Inject literal values:
	1. Create the setter method;

	2. Configure the injection in Spring config file

	<property name="emailAddress" value="123456@789.com" />
	setter method has format limit


Inject literal file from a property files:
	1. Create Properties file;

	name-value pair:
	foo.email = ...
	foo.team = ...

	2. Load Properties file in spring config file

	<context: property-placeholder location="classpath:filename"/>

	3. reference values from properties file

	${the prop name}
	<property name="emailAddress" value="${foo.email}" />


Bean Scopes:

Singleton: 
	create only one instance of the bean, all requests for the bean will return a SHARED reference to the SAME bean

	Coach theCoach context.getBean("myCoach", Coach.class);
	Coach alphaCoach = context.getBean("myCoach", Coach.class);

	all above points to the same bean, it only creates one bean

	Explicitly specify Bean Scope:
	set bean scope:
		<bean id="myCoach"
			class="com.luv2code.springdemo.BaseballCoach"
			scope="singleton">
			<constructor-arg ref="myFortuneService" />
		</bean>

Additional Spring Bean Scopes:
	prototype request session global-session

prototype:
	new object for each request


Bean Lifecycle method:
	A. container started
	B. Bean instantiated
	C. Dependencies injected
	D. Internal Spring Processing
	E. Your custom init method
	F. Bean is ready for use and container is shutdown
	G. Custom destroy method


Init/Destroy: method configuration
<bean id="myCoach"
	class="com.luv2code.springdemo.BaseballCoach"
	init-method="doMyStartupStuff"
	destroy-method="doMyCleanupStuuff">
</bean>

these methods can have any access modifier(public, protected, private);
any return type (void is most commonly used);
the method cannot accept any arguments, should be no-arg;

Destroy method is not called for beans of scope prototype. This is because the context doesn't keep track of the prototype scope objects (if it does, it will cause a memory leak as spring doesn't know when to dispose it).


Java Annotations:
special labels/ makers added to Java classes;
Provide meta-data about the class


	1. Eable component scanning in Spring config file
	<beans ...>
		<context:component=scan base-package="co.luv2code.springdemo" />
	</beans>

	spring will scan the package automatically and recursively

	2. Add the @Component Annotation to your Java classes
	@Component("thatSillyCoach") //bean ID
	public class RnnisCoach implements Coach{
		...
	}

	3. Retrieve bean from Spring container
	Coach theCoach = context.getBean("thatSillyCoach", Coach.class);



Default Bean ID:
	the class name, make the first letter lower-case
	TennisCoach --> tennisCoach
	Use the default, does not have to give a specific bean id
	when the spring cannot find the corresponding bean id, it throws NoSuchBeanDefinitionException error!


Spring dependency injection using annotations and autowiring:

Constructor injection:
	@Autowired //annotaion for constructor
	Spring will scan for a component

	commented the Autowired annotation. But still it worked:

	As of Spring Framework 4.3, an @Autowired annotation on such a constructor is no longer necessary if the target bean only defines one constructor to begin with. However, if several constructors are available, at least one must be annotated to teach the container which one to use.


Setter injection:
	@Autowired //annotaion for setter

	Autowired method, will do itself automatically, do not have to call it!Including constuctor method and setter method!!!


Method injection:
	Any method, just add @Autowired, Spring will seach for the class, it will run automatically


Field injection:
	inject dependencies by setting field values on your class directly, even private fields
	Accomplished by Java reflection

	no need for setter method;

	place @Autowired directly on the field


Multiple implementations:
	It will throw exceptions, NoUniqueBeanDefinitionException;
	need to tell Spring which bean to use
	@Qualifier("happyFortuneService"), give the bean id! Even the default id.

	can apply on constructor, setter, field injection


RandomService --> randomService (default ID)

RESTFortuneService --> RESTFortuneService (default ID)
No conversion since the first two characters are upper case.
Spring uses the Java Beans Introspector to generate the default bean name.

constructor injection:
//constructor injection
@Autowired
public TennisCoach(@Qualifier("randomFortuneService")FortuneService theFortuneService){
    System.out.println("\nHey! Inside the constructor. Spring will setup the object automatically!");
    this.theFortuneService = theFortuneService;
}
setter method/any other method can use the field injection way!!!


Inject properties file using Java annotations:
	1. Create a properties file to hold your properties. It will be a name value pair.  


	New text file:  src/sport.properties

	foo.email=myeasycoach@luv2code.com
	foo.team=Silly Java Coders

	It must be stored in src/sport.properties

	2. Load the properties file in the XML config file.
	<context:property-placeholder location="classpath:sport.properties"/>  

	3. Inject the properties values into your Swim Coach: SwimCoach.java

	@Value("${foo.email}")
	private String email;
	    
	@Value("${foo.team}")
	private String team;


Bean Scopes with Annotations:
	specify Bean Scope using annotations,
	@Scope("prototype")

Bean Lifecycle Methods with Annotations:
	1. Define the init method and destroy method
	2. Add annotations: @PostConstruct @PreDestroy

	you can give any method name!!!

	@PostContruct and @PreDestroy methods.

	Access modifier

	The method can have any access modifier (public, protected, private)

	Return type
	The method can have any return type. However, "void' is most commonly used. If you give a return type just note that you will not be able to capture the return value. As a result, "void" is commonly used.

	Method name
	The method can have any method name.

	Arguments
	The method can not accept any arguments. The method should be no-arg.

	in the case of prototypes, configured destruction lifecycle callbacks are not called.



Java Configuration Class: No XML
	1. Create a Java class and annotate as @Configuration
	2. Add component scanning support: @ComponentScan
	3. Read Spring Java configuration class
	AnnotationConfigApplicationContext context = 
		new AnnotationConfigApplicationContext(SportConfig.class);
	4. Retrieve bean from Spring container


1. Define method to expose bean

	@Bean
	public Coach swimCoach() { //this is also the bean id
		SwimCoach mySwimCoach = ...
	}


2. Inject bean dependencies

3. Read Spring Java configuration class

4. Retrieve bean from Spring container



Inject values from properties file:
1. Create Properties File
2. Load
@PropertySource("")
3. Reference Values
@Value("${foo.email}")


Spring MVC: Model-View-Controller
Documentation: www.luv2code.com/spring-mvc-docs

view tempplates: JSP + JSTL

Apache Tomcat
Eclipse(Java EE version)
Connected TomCat to Eclipse


MVC development process:
	1. Create controller class
	@Controller
	it inherits from @Component, supports scanning

	2. Define controller method
	@Controller

	3. Add request mapping to controller method
	@RequestMapping("/")

	4. Return view name

	5. Develop view page





























































































